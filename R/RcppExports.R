# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Clean things up
#'
#' @export
freeSpace <- function() {
    invisible(.Call('_rSpectral_freeSpace', PACKAGE = 'rSpectral'))
}

#' Load edge list for analysis
#' 
#' This function reads the edge list and creates the network for analysis. It does 
#' not return anything, it just creates required structures in memory.
#'
#' @param df edge list
#' @param names are we dealing with alphaNumeric (1) or numeric (!1) ids
#'
#' @export
#'
#' @examples
#' library(igraph)
#' g <- make_full_graph(5) %du% make_full_graph(5) %du% make_full_graph(5)
#' g <- add_edges(g, c(1,6, 1,11, 6, 11))
#' el = as.data.frame(get.edgelist(g,names=TRUE))
#' rSpectral::load_data(df=el)
#' status = rSpectral::spectral(fix_neig=0)
#' spec   = rSpectral::membership(detach_graph=1)
load_data <- function(df, names = 1L) {
    invisible(.Call('_rSpectral_load_data', PACKAGE = 'rSpectral', df, names))
}

#' Spectral modularity clustering
#' 
#' This function does the actual job of clustering. Two major parameter are
#' \code{Cn_min}, which controls the minimal size of the cluster, 
#' and \code{fix_neig}, which can reduce execution time by factor 2 to 5 by
#' checking only boundary nodes of already found clusters. Optimal set of 
#' parameters could be obtained by trying different combinations of values and
#' using \code{detach_graph=0} when getting communities by calling 
#' \code{\link{membership}}. 
#'  
#'
#' @param Cn_min minimum cluster size
#' @param tol tolerance
#' @param names are we dealing with alphaNumeric (1) or numeric (!1) ids
#' @param fix_neig wether fixing neighbouring nodes found in same community
#'
#' @return status (does it really return something?)
#' @export
#' @examples
#' library(igraph)
#' g <- make_full_graph(5) %du% make_full_graph(5) %du% make_full_graph(5)
#' g <- add_edges(g, c(1,6, 1,11, 6, 11))
#' el = as.data.frame(get.edgelist(g,names=TRUE))
#' rSpectral::load_data(df=el)
#' status = rSpectral::spectral(fix_neig=0)
#' spec   = rSpectral::membership(detach_graph=1)
#' V(g)$color[as.numeric(spec$ID)]<-RColorBrewer::brewer.pal(max(spec$K),'Set1')[spec$K]
#' plot(g)
spectral <- function(Cn_min = 1L, tol = 0.00001, names = 1L, fix_neig = 0L) {
    invisible(.Call('_rSpectral_spectral', PACKAGE = 'rSpectral', Cn_min, tol, names, fix_neig))
}

#' Return membership data
#'
#' Returns membership data calculated by previous call to \code{\link{spectral}}.
#' If \code{detach_grap} is set to 1 (default) all in-memory data will be cleaned up
#' on return, if \code{detach_grap} is set to 0 the graph stays in memory,
#' so several sets of parameters such as \code{fix_neig}, or \code{Cn_min} 
#' could be evaluated to identify the best clustering for the graph at hand.
#' 
#' @param detach_graph whether you want to keep graph in memory
#'
#' @return membership vector
#' @export
#'
#' @examples
#' library(igraph)
#' g <- make_full_graph(5) %du% make_full_graph(5) %du% make_full_graph(5)
#' g <- add_edges(g, c(1,6, 1,11, 6, 11))
#' el = as.data.frame(get.edgelist(g,names=TRUE))
#' rSpectral::load_data(df=el)
#' status1 = rSpectral::spectral(fix_neig=0)
#' spec1   = rSpectral::membership(detach_graph=0)
#' status2 = rSpectral::spectral(fix_neig=1)
#' spec2   = rSpectral::membership(detach_graph=0)
membership <- function(detach_graph = 1L) {
    .Call('_rSpectral_membership', PACKAGE = 'rSpectral', detach_graph)
}

